#lang racket

(define (_eq? x y) (eq? x y))
(define (_apply f xs) (apply f xs))
(define (_car x) (car x))
(define (_cdr x) (cdr x))
(define (_pair? x) (pair? x))
(define (_cons x y) (cons x y))
(define (_null? x) (null? x))
(define (_boolean? x) (boolean? x))
(define (_string? x) (string? x))
(define (_string->list x) (string->list x))
(define (_list->string x) (list->string x))
(define (_char? x) (char? x))
(define (_char->integer x) (char->integer x))
(define (_integer->char x) (integer->char x))
(define (_integer? x) (integer? x))
(define (_+ x y) (+ x y))
(define (_- x y) (- x y))
(define (_* x y) (* x y))
(define (_/ x y) (/ x y))
(define (_= x y) (= x y))
(define (_< x y) (< x y))
(define (_> x y) (> x y))
(define (_<= x y) (<= x y))
(define (_>= x y) (>= x y))
(define (_vector? x) (vector? x))
(define (_list->vector x) (list->vector x))
(define (_vector->list x) (vector->list x))
(define (_vector-length x) (vector-length x))
(define (_vector-ref v x) (vector-ref v x))

(define top-level
  (list
   (cons 'eq? _eq?)
   (cons 'apply _apply)
   (cons 'car _car)
   (cons 'cdr _cdr)
   (cons 'pair? _pair?)
   (cons 'cons _cons)
   (cons 'null? _null?)
   (cons 'boolean? _boolean?)
   (cons 'string? _string?)
   (cons 'string->list _string->list)
   (cons 'list->string _list->string)
   (cons 'char? _char?)
   (cons 'char->integer _char->integer)
   (cons 'integer->char _integer->char)
   (cons 'integer? _integer?)
   (cons '+ _+)
   (cons '- _-)
   (cons '* _*)
   (cons '/ _/)
   (cons '= _=)
   (cons '< _<)
   (cons '> _>)
   (cons '<= _<=)
   (cons '>= _>=)
   (cons 'vector? _vector?)
   (cons 'list->vector _list->vector)
   (cons 'vector->list _vector->list)
   (cons 'vector-length _vector-length)
   (cons 'vector-ref _vector-ref)))

(define (_eval x env)
  (cond
    ((list? x)
     (let ((f (car x)) (xs (cdr x)))
       (cond
         ((eq? f 'quote)
          (if (and (pair? xs) (null? (cdr xs)))
              (car xs)
              (error "illegal quote")))
         ((eq? f 'lambda)
          (if (= (length xs) 2)
              (let ((args (car xs)) (body (car (cdr xs))))
                (error "todo"))
              (error "illegal lambda")))
         ((eq? f 'if)
          (if (= (length xs) 3)
              (let ((b (car xs)) (x (car (cdr xs))) (y (car (cdr (cdr xs)))))
                (if (_eval b env) (_eval x env) (_eval y env)))
              (error "illegal if")))
         ((eq? f 'letrec) (error "todo"))
         (else (apply (_eval f env) (map (lambda (v) (_eval v env)) xs))))))
    ((symbol? x)
     (let ((p (assoc x env)))
       (if (eq? p #f)
           (error "no definition")
           (cdr p))))
    ((or (integer? x) (vector? x)) x)
    (else (error "illegal expression"))))

