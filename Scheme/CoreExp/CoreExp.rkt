#lang racket

(define (_eq? x y) (eq? x y))
(define (_apply f xs) (apply f xs))
(define (_car x) (car x))
(define (_cdr x) (cdr x))
(define (_pair? x) (pair? x))
(define (_cons x y) (cons x y))
(define (_null? x) (null? x))
(define (_boolean? x) (boolean? x))
(define (_string? x) (string? x))
(define (_string->list x) (string->list x))
(define (_list->string x) (list->string x))
(define (_char? x) (char? x))
(define (_char->integer x) (char->integer x))
(define (_integer->char x) (integer->char x))
(define (_integer? x) (integer? x))
(define (_+ x y) (+ x y))
(define (_- x y) (- x y))
(define (_* x y) (* x y))
(define (_/ x y) (/ x y))
(define (_= x y) (= x y))
(define (_< x y) (< x y))
(define (_> x y) (> x y))
(define (_<= x y) (<= x y))
(define (_>= x y) (>= x y))
(define (_vector? x) (vector? x))
(define (_list->vector x) (list->vector x))
(define (_vector->list x) (vector->list x))
(define (_vector-length x) (vector-length x))
(define (_vector-ref v x) (vector-ref v x))

(define top-level
  (list
   (cons 'eq? _eq?)
   (cons 'apply _apply)
   (cons 'car _car)
   (cons 'cdr _cdr)
   (cons 'pair? _pair?)
   (cons 'cons _cons)
   (cons 'null? _null?)
   (cons 'boolean? _boolean?)
   (cons 'string? _string?)
   (cons 'string->list _string->list)
   (cons 'list->string _list->string)
   (cons 'char? _char?)
   (cons 'char->integer _char->integer)
   (cons 'integer->char _integer->char)
   (cons 'integer? _integer?)
   (cons '+ _+)
   (cons '- _-)
   (cons '* _*)
   (cons '/ _/)
   (cons '= _=)
   (cons '< _<)
   (cons '> _>)
   (cons '<= _<=)
   (cons '>= _>=)
   (cons 'vector? _vector?)
   (cons 'list->vector _list->vector)
   (cons 'vector->list _vector->list)
   (cons 'vector-length _vector-length)
   (cons 'vector-ref _vector-ref)))

(define (_eval x env)
  (cond
    ((list? x)
     (let ((f (car x)) (xs (cdr x)))
       (cond
         ((eq? f 'quote)
          (if (and (pair? xs) (null? (cdr xs)))
              (car xs)
              (error "illegal quote")))
         ((eq? f 'lambda)
          (if (= (length xs) 2)
              (let ((parsed-args (parse-args (car xs))) (body (car (cdr xs))))
                (let ((maybe-rest (car parsed-args)) (main-pattern (cdr parsed-args)))
                  (lambda xs (_eval body (match-args maybe-rest main-pattern xs env)))))
              (error "illegal lambda")))
         ((eq? f 'if)
          (if (= (length xs) 3)
              (let ((b (car xs)) (x (car (cdr xs))) (y (car (cdr (cdr xs)))))
                (if (_eval b env) (_eval x env) (_eval y env)))
              (error "illegal if")))
         ((eq? f 'letrec) (error "todo"))
         (else (apply (_eval f env) (map (lambda (v) (_eval v env)) xs))))))
    ((symbol? x)
     (let ((p (assoc x env)))
       (if (eq? p #f)
           (error "no definition")
           (cdr p))))
    ((or (integer? x) (vector? x)) x)
    (else (error "illegal expression"))))

(define (parse-args args); -> Maybe Symbol * Listof Symbol
  (cond
    ((symbol? args) (cons args '()))
    ((null? args) (cons #f '()))
    ((pair? args)
     (if (symbol? (car args))
         (let ((r (parse-args (cdr args))))
           (cons (car r) (cons (car args) (cdr r))))
         (error "not symbol")))
    (else (error "illegal arguments pattern"))))

(define (match-args maybe-rest main-pattern xs env)
  (if (symbol? maybe-rest)
      (if (null? main-pattern)
          (cons (cons maybe-rest xs) env)
          (if (pair? xs)
              (match-args maybe-rest (cdr main-pattern) (cdr xs) (cons (cons (car main-pattern) (car xs)) env))
              (error "not enough arguments")))
      (if (null? main-pattern)
          (if (null? xs)
              env
              (error "too many arguments"))
          (if (pair? xs)
              (match-args maybe-rest (cdr main-pattern) (cdr xs) (cons (cons (car main-pattern) (car xs)) env))
              (error "not enough arguments")))))
