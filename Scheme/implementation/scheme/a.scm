#lang racket

(define (_eq? x y) (eq? x y))
(define (_apply f xs) (apply f xs))
(define (_car x) (car x))
(define (_cdr x) (cdr x))
(define (_pair? x) (pair? x))
(define (_cons x y) (cons x y))
(define (_null? x) (null? x))
(define (_boolean? x) (boolean? x))
(define (_string? x) (string? x))
(define (_string->list x) (string->list x))
(define (_list->string x) (list->string x))
(define (_char? x) (char? x))
(define (_char->integer x) (char->integer x))
(define (_integer->char x) (integer->char x))
(define (_integer? x) (integer? x))
(define (_+ x y) (+ x y))
(define (_- x y) (- x y))
(define (_* x y) (* x y))
(define (_/ x y) (/ x y))
(define (_= x y) (= x y))
(define (_< x y) (< x y))
(define (_> x y) (> x y))
(define (_<= x y) (<= x y))
(define (_>= x y) (>= x y))
(define (_vector? x) (vector? x))
(define (_list->vector x) (list->vector x))
(define (_vector->list x) (vector->list x))
(define (_vector-length x) (vector-length x))
(define (_vector-ref v x) (vector-ref v x))

(define top-level
  (list
   (cons 'eq? _eq?)
   (cons 'apply _apply)
   (cons 'car _car)
   (cons 'cdr _cdr)
   (cons 'pair? _pair?)
   (cons 'cons _cons)
   (cons 'null? _null?)
   (cons 'boolean? _boolean?)
   (cons 'string? _string?)
   (cons 'string->list _string->list)
   (cons 'list->string _list->string)
   (cons 'char? _char?)
   (cons 'char->integer _char->integer)
   (cons 'integer->char _integer->char)
   (cons 'integer? _integer?)
   (cons '+ _+)
   (cons '- _-)
   (cons '* _*)
   (cons '/ _/)
   (cons '= _=)
   (cons '< _<)
   (cons '> _>)
   (cons '<= _<=)
   (cons '>= _>=)
   (cons 'vector? _vector?)
   (cons 'list->vector _list->vector)
   (cons 'vector->list _vector->list)
   (cons 'vector-length _vector-length)
   (cons 'vector-ref _vector-ref)))

(define empty-mapping '())
(define (mapping-assoc k m) (assq k m))
(define (mapping-map f m) (map f m))
(define (mapping-merge m1 m2) (append m1 m2))
(define (mapping-updated k v m) (cons (cons k v) m))

(define (check-args args)
  (cond
    ((symbol? args) #t)
    ((null? args) #t)
    ((pair? args) (and (symbol? (car args)) (check-args (cdr args))))
    (else #f)))
(define (apply-args args xs env)
  (cond
    ((pair? args)
     (if (pair? xs)
         (apply-args (cdr args) (cdr xs) (mapping-updated (car args) (car xs) env))
         (error "apply" "not enough arguments")))
    ((null? args)
     (if (null? xs)
         env
         (error "apply" "too many arguments")))
    ((symbol? args) (mapping-updated args xs env))
    (else (error "apply" "illegal arguments pattern"))))

(define (_e x env letrec-env); env: Listof (Symbol * Any) ; letrec-env: Listof (Symbol * => Any)
  (cond
    ((null? x) (error "eval" "null"))
    ((symbol? x)
     (cond
       ((mapping-assoc x letrec-env) (error "eval" "the variable will be defined" x))
       ((mapping-assoc x env) => cdr)
       (else (error "eval" "the variable is not defined" x))))
    ((or (vector? x) (integer? x) (char? x) (string? x)) x)
    ((list? x)
     (let ((f (car x)) (xs (cdr x)))
       (cond
         ((symbol? f)
          (cond
            ((mapping-assoc f letrec-env) (error "eval" "the variable will be defined" f))
            ((mapping-assoc f env) => (lambda (v) (apply (cdr v) (map (lambda (x) (_e x env empty-mapping)) xs))))
            ((eq? f 'quote)
             (if (= (length xs) 1)
                 (car xs)
                 (error "eval" "illegal quote" x)))
            ((eq? f 'lambda)
             (if (= (length xs) 2)
                 (let ((args (car xs)) (body (car (cdr xs))))
                   (if (check-args args)
                       (lambda xs (_e body (apply-args args xs (mapping-merge (mapping-map (lambda (e) (cons (car e) ((cdr e)))) letrec-env) env)) empty-mapping))
                       (error "eval" "illegal arguments pattern")))
                 (error "eval" "illegal lambda")))
            ((eq? f 'letrec)
             (if (= (length xs) 2)
                 (let ((parsed-lets (parse-let (car xs))) (body (car (cdr xs))))
                   (letrec ((inner-letrec-env (mapping-merge (map (lambda (x) (let ((name (car x))) (cons name (lambda () (cdr (mapping-assoc name inner-env)))))) parsed-lets) letrec-env))
                            (inner-env (map (lambda (x) (cons (car x) (_e (cdr x) env inner-letrec-env))) parsed-lets)))
                     (_e body (mapping-merge inner-env env) letrec-env)))
                 (error "eval" "illegal letrec" x)))
            ((eq? f 'if)
             (if (= (length xs) 3)
                 (let ((b (car xs)) (x (car (cdr xs))) (y (car (cdr (cdr xs)))))
                   (if (_e b env letrec-env) (_e x env letrec-env) (_e y env letrec-env)))
                 (error "eval" "illegal if")))))
         (else (apply (_e f env letrec-env) (map (lambda (x) (_e x env empty-mapping)) xs))))))
    (else (error "eval" "illegal expression" x))))

(define (parse-let xs); -> Listof (Symbol * Any)
  (if (list? xs)
      (map (lambda (element)
             (if (and (list? element) (= (length element) 2) (symbol? (car element)))
                 (cons (car element) (car (cdr element)))
                 (error "eval" "illegal let"))) xs)
      (error "eval" "illegal let")))

(define (evaluate x . rest)
  (cond
    ((null? rest) (_e x top-level empty-mapping))
    ((= (length rest) 1) (_e x (car rest) empty-mapping))
    (else (error "evaluate" "too many arguments" (cons x rest)))))

; ------------- tests ---------

(define (test-check title tested-expression expected-result)
  (if (equal? tested-expression expected-result)
      #t
      (error (string-append "Failed:" title))))

(test-check "'(a b c)" (evaluate '(quote (a b c))) '(a b c))

(define .list '(lambda xs xs))

(test-check "(list 'a 'b 'c)" (evaluate `(,.list (quote a) (quote b) (quote c))) '(a b c))

(define .id '(lambda (x) x))

(test-check "((id (id id)) 'a)" (evaluate `((,.id (,.id ,.id)) 'a)) 'a)

(test-check
 "simple letrec"
 (evaluate
  '(letrec ((foo (lambda () bar))
            (bar 7))
     (cons (foo) bar)))
 '(7 . 7))